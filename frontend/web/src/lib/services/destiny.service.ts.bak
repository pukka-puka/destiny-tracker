import { 
  collection, 
  addDoc, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs,
  doc,
  getDoc,
  Timestamp,
  DocumentData
} from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { db, storage, auth } from '@/lib/firebase';
import { 
  DestinyReading, 
  DestinyParameters,
  TarotCard,
  TarotReadingData,
  DailyFortune
} from '@/types/destiny.types';

// タロット占いを保存
export async function saveTarotReading(
  cards: TarotCard[],
  interpretation: string,
  category: 'general' | 'love' | 'career' | 'money' = 'general'
): Promise<string> {
  const user = auth.currentUser;
  if (!user) throw new Error('User not authenticated');

  // パラメーター計算（仮の実装）
  const parameters: DestinyParameters = {
    love: Math.floor(Math.random() * 40) + 60,
    career: Math.floor(Math.random() * 40) + 60,
    money: Math.floor(Math.random() * 40) + 60,
    health: Math.floor(Math.random() * 40) + 60,
    social: Math.floor(Math.random() * 40) + 60,
    growth: Math.floor(Math.random() * 40) + 60,
  };

  // カテゴリに応じてパラメーターを調整
  if (category === 'love') parameters.love = Math.min(100, parameters.love + 20);
  if (category === 'career') parameters.career = Math.min(100, parameters.career + 20);
  if (category === 'money') parameters.money = Math.min(100, parameters.money + 20);

  const reading: Omit<DestinyReading, 'id'> = {
    userId: user.uid,
    readingType: 'daily-tarot',
    parameters,
    daily: {
      date: new Date().toISOString().split('T')[0],
      fortune: Math.floor(Math.random() * 40) + 60,
      message: interpretation.substring(0, 200),
      luckyColor: ['赤', '青', '黄', '緑', '紫'][Math.floor(Math.random() * 5)],
      luckyNumber: Math.floor(Math.random() * 9) + 1,
    },
    tarotReading: {
      cards: cards.map(c => ({
        id: c.id,
        name: c.name,
        meaning: c.meaning,
        reversed: c.reversed || false,
        image: c.image
      })),
      interpretation,
      category,
      spreadType: 'three-card',
    },
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  };

  const docRef = await addDoc(collection(db, 'readings'), reading);
  return docRef.id;
}

// 最新の占い結果を取得
export async function getLatestReadings(
  userId: string, 
  readingType?: 'daily-tarot' | 'palm' | 'special',
  limitCount: number = 10
): Promise<DestinyReading[]> {
  let q = query(
    collection(db, 'readings'),
    where('userId', '==', userId)
  );

  if (readingType) {
    q = query(q, where('readingType', '==', readingType));
  }

  q = query(q, orderBy('createdAt', 'desc'), limit(limitCount));

  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  } as DestinyReading));
}

// 今日の運勢を取得
export async function getTodaysFortune(userId: string): Promise<DailyFortune | null> {
  const today = new Date().toISOString().split('T')[0];
  
  const q = query(
    collection(db, 'readings'),
    where('userId', '==', userId),
    where('readingType', '==', 'daily-tarot'),
    where('daily.date', '==', today),
    orderBy('createdAt', 'desc'),
    limit(1)
  );

  const snapshot = await getDocs(q);
  
  if (snapshot.empty) return null;
  
  const reading = snapshot.docs[0].data() as DestinyReading;
  return reading.daily || null;
}

// 統計情報を取得
export async function getUserStatistics(userId: string) {
  // 全ての占い回数
  const allReadings = await getLatestReadings(userId, undefined, 1000);
  
  // タロット占い回数
  const tarotCount = allReadings.filter(r => r.readingType === 'daily-tarot').length;
  
  // 手相占い回数
  const palmCount = allReadings.filter(r => r.readingType === 'palm').length;

  // 平均パラメーター
  const avgParameters: DestinyParameters = {
    love: 0,
    career: 0,
    money: 0,
    health: 0,
    social: 0,
    growth: 0,
  };

  if (allReadings.length > 0) {
    allReadings.forEach(reading => {
      Object.keys(avgParameters).forEach(key => {
        const param = key as keyof DestinyParameters;
        avgParameters[param] += reading.parameters[param];
      });
    });

    Object.keys(avgParameters).forEach(key => {
      const param = key as keyof DestinyParameters;
      avgParameters[param] = Math.round(avgParameters[param] / allReadings.length);
    });
  }

  return {
    totalReadings: allReadings.length,
    tarotCount,
    palmCount,
    averageParameters: avgParameters,
    readings: allReadings.slice(0, 10), // 最新10件
  };
}

// 占い履歴を期間で取得
export async function getReadingsByDateRange(
  userId: string,
  startDate: Date,
  endDate: Date
): Promise<DestinyReading[]> {
  const q = query(
    collection(db, 'readings'),
    where('userId', '==', userId),
    where('createdAt', '>=', Timestamp.fromDate(startDate)),
    where('createdAt', '<=', Timestamp.fromDate(endDate)),
    orderBy('createdAt', 'desc')
  );

  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  } as DestinyReading));
}

// 画像アップロード関数
export async function uploadImage(file: File, path: string): Promise<string> {
  const timestamp = Date.now();
  const fileName = `${timestamp}_${file.name}`;
  const fullPath = `${path}/${fileName}`;
  
  const storageRef = ref(storage, fullPath);
  const snapshot = await uploadBytes(storageRef, file);
  const downloadUrl = await getDownloadURL(snapshot.ref);
  
  return downloadUrl;
}
